// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace GeneratedModels
{
    /// <summary> The  service client. </summary>
    public partial class Client
    {
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of Client for mocking. </summary>
        protected Client()
        {
        }

        /// <summary> Initializes a new instance of Client. </summary>
        /// <param name="endpoint"> The endpoint of the App Configuration instance to send requests to. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> is null. </exception>
        public Client(Uri endpoint) : this(endpoint, new ClientOptions())
        {
        }

        /// <summary> Initializes a new instance of Client. </summary>
        /// <param name="endpoint"> The endpoint of the App Configuration instance to send requests to. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> is null. </exception>
        public Client(Uri endpoint, ClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new ClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), Array.Empty<HttpPipelinePolicy>(), new ResponseClassifier());
            _endpoint = endpoint;
        }

        /// <summary> Gets a list of keys. </summary>
        /// <param name="name"> A filter for the name of the returned keys. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/> or <paramref name="after"/> is null. </exception>
        public virtual async Task<Response<global::.KeyListResult>> GetKeyValuesAsync(string name, string apiVersion, string after, string syncToken = null, string acceptDatetime = null, string accept = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetKeysAsync(name, apiVersion, after, syncToken, acceptDatetime, accept, context).ConfigureAwait(false);
                return Response.FromValue(global::.KeyListResult.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of keys. </summary>
        /// <param name="name"> A filter for the name of the returned keys. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/> or <paramref name="after"/> is null. </exception>
        public virtual Response<global::.KeyListResult> GetKeyValues(string name, string apiVersion, string after, string syncToken = null, string acceptDatetime = null, string accept = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetKeys(name, apiVersion, after, syncToken, acceptDatetime, accept, context);
                return Response.FromValue(global::.KeyListResult.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of keys. </summary>
        /// <param name="name"> A filter for the name of the returned keys. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/> or <paramref name="after"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetKeysAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetKeysAsync("<name>", "<apiVersion>", "<after>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// This sample shows how to call GetKeysAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetKeysAsync("<name>", "<apiVersion>", "<after>", "<syncToken>", "<acceptDatetime>", "<accept>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyListResult</c>:
        /// <code>{
        ///   items: [
        ///     {
        ///       name: string, # Required.
        ///     }
        ///   ], # Required.
        ///   @nextLink: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetKeysAsync(string name, string apiVersion, string after, string syncToken = null, string acceptDatetime = null, string accept = null, RequestContext context = null)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetKeysRequest(name, apiVersion, after, syncToken, acceptDatetime, accept, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of keys. </summary>
        /// <param name="name"> A filter for the name of the returned keys. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/> or <paramref name="after"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetKeys with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetKeys("<name>", "<apiVersion>", "<after>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// This sample shows how to call GetKeys with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetKeys("<name>", "<apiVersion>", "<after>", "<syncToken>", "<acceptDatetime>", "<accept>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyListResult</c>:
        /// <code>{
        ///   items: [
        ///     {
        ///       name: string, # Required.
        ///     }
        ///   ], # Required.
        ///   @nextLink: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetKeys(string name, string apiVersion, string after, string syncToken = null, string acceptDatetime = null, string accept = null, RequestContext context = null)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetKeysRequest(name, apiVersion, after, syncToken, acceptDatetime, accept, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="name"> A filter for the name of the returned keys. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/> or <paramref name="after"/> is null. </exception>
        public virtual async Task<Response> CheckKeyValuesAsync(string name, string apiVersion, string after, string syncToken = null, string acceptDatetime = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await CheckKeysAsync(name, apiVersion, after, syncToken, acceptDatetime, context).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="name"> A filter for the name of the returned keys. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/> or <paramref name="after"/> is null. </exception>
        public virtual Response CheckKeyValues(string name, string apiVersion, string after, string syncToken = null, string acceptDatetime = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = CheckKeys(name, apiVersion, after, syncToken, acceptDatetime, context);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="name"> A filter for the name of the returned keys. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/> or <paramref name="after"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckKeysAsync with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckKeysAsync("<name>", "<apiVersion>", "<after>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckKeysAsync with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckKeysAsync("<name>", "<apiVersion>", "<after>", "<syncToken>", "<acceptDatetime>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> CheckKeysAsync(string name, string apiVersion, string after, string syncToken = null, string acceptDatetime = null, RequestContext context = null)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckKeysRequest(name, apiVersion, after, syncToken, acceptDatetime, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="name"> A filter for the name of the returned keys. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/> or <paramref name="after"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckKeys with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckKeys("<name>", "<apiVersion>", "<after>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckKeys with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckKeys("<name>", "<apiVersion>", "<after>", "<syncToken>", "<acceptDatetime>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response CheckKeys(string name, string apiVersion, string after, string syncToken = null, string acceptDatetime = null, RequestContext context = null)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeys");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckKeysRequest(name, apiVersion, after, syncToken, acceptDatetime, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of key-values. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/> or <paramref name="select"/> is null. </exception>
        public virtual async Task<Response<global::.KeyValueListResult>> GetKeyValueValuesAsync(string key, string label, string apiVersion, string after, IEnumerable<global::.Get6ItemsItem> select, string syncToken = null, string acceptDatetime = null, string accept = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValueValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetKeyValuesAsync(key, label, apiVersion, after, select, syncToken, acceptDatetime, accept, context).ConfigureAwait(false);
                return Response.FromValue(global::.KeyValueListResult.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of key-values. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/> or <paramref name="select"/> is null. </exception>
        public virtual Response<global::.KeyValueListResult> GetKeyValueValues(string key, string label, string apiVersion, string after, IEnumerable<global::.Get6ItemsItem> select, string syncToken = null, string acceptDatetime = null, string accept = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValueValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetKeyValues(key, label, apiVersion, after, select, syncToken, acceptDatetime, accept, context);
                return Response.FromValue(global::.KeyValueListResult.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of key-values. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetKeyValuesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetKeyValuesAsync("<key>", "<label>", "<apiVersion>", "<after>", new Get6ItemsItem[]{null});
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("etag").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// This sample shows how to call GetKeyValuesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetKeyValuesAsync("<key>", "<label>", "<apiVersion>", "<after>", new Get6ItemsItem[]{null}, "<syncToken>", "<acceptDatetime>", "<accept>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("etag").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValueListResult</c>:
        /// <code>{
        ///   items: [
        ///     {
        ///       key: string, # Required.
        ///       label: string, # Required.
        ///       content_type: string, # Required.
        ///       value: string, # Required.
        ///       last_modified: string (date &amp; time), # Required.
        ///       tags: Dictionary&lt;string, string&gt;, # Required.
        ///       locked: boolean, # Required.
        ///       etag: string, # Required.
        ///     }
        ///   ], # Required.
        ///   @nextLink: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetKeyValuesAsync(string key, string label, string apiVersion, string after, IEnumerable<global::.Get6ItemsItem> select, string syncToken = null, string acceptDatetime = null, string accept = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValues");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetKeyValuesRequest(key, label, apiVersion, after, select, syncToken, acceptDatetime, accept, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of key-values. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetKeyValues with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetKeyValues("<key>", "<label>", "<apiVersion>", "<after>", new Get6ItemsItem[]{null});
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("etag").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// This sample shows how to call GetKeyValues with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetKeyValues("<key>", "<label>", "<apiVersion>", "<after>", new Get6ItemsItem[]{null}, "<syncToken>", "<acceptDatetime>", "<accept>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("etag").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValueListResult</c>:
        /// <code>{
        ///   items: [
        ///     {
        ///       key: string, # Required.
        ///       label: string, # Required.
        ///       content_type: string, # Required.
        ///       value: string, # Required.
        ///       last_modified: string (date &amp; time), # Required.
        ///       tags: Dictionary&lt;string, string&gt;, # Required.
        ///       locked: boolean, # Required.
        ///       etag: string, # Required.
        ///     }
        ///   ], # Required.
        ///   @nextLink: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetKeyValues(string key, string label, string apiVersion, string after, IEnumerable<global::.Get6ItemsItem> select, string syncToken = null, string acceptDatetime = null, string accept = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValues");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetKeyValuesRequest(key, label, apiVersion, after, select, syncToken, acceptDatetime, accept, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual async Task<Response> CheckKeyValueValuesAsync(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head6ItemsItem> select, string syncToken = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValueValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await CheckKeyValuesAsync(key, label, apiVersion, after, acceptDatetime, select, syncToken, context).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual Response CheckKeyValueValues(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head6ItemsItem> select, string syncToken = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValueValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = CheckKeyValues(key, label, apiVersion, after, acceptDatetime, select, syncToken, context);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckKeyValuesAsync with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckKeyValuesAsync("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new Head6ItemsItem[]{null});
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckKeyValuesAsync with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckKeyValuesAsync("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new Head6ItemsItem[]{null}, "<syncToken>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> CheckKeyValuesAsync(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head6ItemsItem> select, string syncToken = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValues");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckKeyValuesRequest(key, label, apiVersion, after, acceptDatetime, select, syncToken, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckKeyValues with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckKeyValues("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new Head6ItemsItem[]{null});
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckKeyValues with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckKeyValues("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new Head6ItemsItem[]{null}, "<syncToken>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response CheckKeyValues(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head6ItemsItem> select, string syncToken = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValues");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckKeyValuesRequest(key, label, apiVersion, after, acceptDatetime, select, syncToken, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a single key-value. </summary>
        /// <param name="key"> The key of the key-value to retrieve. </param>
        /// <param name="label"> The label of the key-value to retrieve. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual async Task<Response<global::.KeyValue>> GetKeyValueValueAsync(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Get7ItemsItem> select, string syncToken = null, string accept = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValueValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetKeyValueAsync(key, label, apiVersion, acceptDatetime, select, syncToken, accept, matchConditions, context).ConfigureAwait(false);
                return Response.FromValue(global::.KeyValue.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a single key-value. </summary>
        /// <param name="key"> The key of the key-value to retrieve. </param>
        /// <param name="label"> The label of the key-value to retrieve. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual Response<global::.KeyValue> GetKeyValueValue(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Get7ItemsItem> select, string syncToken = null, string accept = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValueValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetKeyValue(key, label, apiVersion, acceptDatetime, select, syncToken, accept, matchConditions, context);
                return Response.FromValue(global::.KeyValue.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a single key-value. </summary>
        /// <param name="key"> The key of the key-value to retrieve. </param>
        /// <param name="label"> The label of the key-value to retrieve. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetKeyValueAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetKeyValueAsync("<key>", "<label>", "<apiVersion>", "<acceptDatetime>", new Get7ItemsItem[]{null});
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call GetKeyValueAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetKeyValueAsync("<key>", "<label>", "<apiVersion>", "<acceptDatetime>", new Get7ItemsItem[]{null}, "<syncToken>", "<accept>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetKeyValueAsync(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Get7ItemsItem> select, string syncToken = null, string accept = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValue");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetKeyValueRequest(key, label, apiVersion, acceptDatetime, select, syncToken, accept, matchConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a single key-value. </summary>
        /// <param name="key"> The key of the key-value to retrieve. </param>
        /// <param name="label"> The label of the key-value to retrieve. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetKeyValue with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetKeyValue("<key>", "<label>", "<apiVersion>", "<acceptDatetime>", new Get7ItemsItem[]{null});
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call GetKeyValue with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetKeyValue("<key>", "<label>", "<apiVersion>", "<acceptDatetime>", new Get7ItemsItem[]{null}, "<syncToken>", "<accept>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetKeyValue(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Get7ItemsItem> select, string syncToken = null, string accept = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetKeyValue");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetKeyValueRequest(key, label, apiVersion, acceptDatetime, select, syncToken, accept, matchConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a key-value. </summary>
        /// <param name="key"> The key of the key-value to create. </param>
        /// <param name="label"> The label of the key-value to create. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="entity"> The key-value to create. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/> or <paramref name="entity"/> is null. </exception>
        public virtual async Task<Response<global::.KeyValue>> PutKeyValueAsync(string key, string label, string apiVersion, global::.KeyValue entity, string syncToken = null, string accept = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(entity, nameof(entity));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await PutKeyValueAsync(key, label, apiVersion, entity.ToRequestContent(), syncToken, accept, matchConditions, context).ConfigureAwait(false);
            return Response.FromValue(global::.KeyValue.FromResponse(response), response);
        }

        /// <summary> Creates a key-value. </summary>
        /// <param name="key"> The key of the key-value to create. </param>
        /// <param name="label"> The label of the key-value to create. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="entity"> The key-value to create. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/> or <paramref name="entity"/> is null. </exception>
        public virtual Response<global::.KeyValue> PutKeyValue(string key, string label, string apiVersion, global::.KeyValue entity, string syncToken = null, string accept = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(entity, nameof(entity));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = PutKeyValue(key, label, apiVersion, entity.ToRequestContent(), syncToken, accept, matchConditions, context);
            return Response.FromValue(global::.KeyValue.FromResponse(response), response);
        }

        /// <summary> Creates a key-value. </summary>
        /// <param name="key"> The key of the key-value to create. </param>
        /// <param name="label"> The label of the key-value to create. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call PutKeyValueAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// var data = new {
        ///     key = "<key>",
        ///     label = "<label>",
        ///     content_type = "<content_type>",
        ///     value = "<value>",
        ///     last_modified = "2022-05-10T14:57:31.2311892-04:00",
        ///     tags = new {
        ///         key = "<String>",
        ///     },
        ///     locked = true,
        ///     etag = "<etag>",
        /// };
        /// 
        /// Response response = await client.PutKeyValueAsync("<key>", "<label>", "<apiVersion>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call PutKeyValueAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// var data = new {
        ///     key = "<key>",
        ///     label = "<label>",
        ///     content_type = "<content_type>",
        ///     value = "<value>",
        ///     last_modified = "2022-05-10T14:57:31.2311892-04:00",
        ///     tags = new {
        ///         key = "<String>",
        ///     },
        ///     locked = true,
        ///     etag = "<etag>",
        /// };
        /// 
        /// Response response = await client.PutKeyValueAsync("<key>", "<label>", "<apiVersion>", RequestContent.Create(data), "<syncToken>", "<accept>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> PutKeyValueAsync(string key, string label, string apiVersion, RequestContent content, string syncToken = null, string accept = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Client.PutKeyValue");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePutKeyValueRequest(key, label, apiVersion, content, syncToken, accept, matchConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a key-value. </summary>
        /// <param name="key"> The key of the key-value to create. </param>
        /// <param name="label"> The label of the key-value to create. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call PutKeyValue with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// var data = new {
        ///     key = "<key>",
        ///     label = "<label>",
        ///     content_type = "<content_type>",
        ///     value = "<value>",
        ///     last_modified = "2022-05-10T14:57:31.2311892-04:00",
        ///     tags = new {
        ///         key = "<String>",
        ///     },
        ///     locked = true,
        ///     etag = "<etag>",
        /// };
        /// 
        /// Response response = client.PutKeyValue("<key>", "<label>", "<apiVersion>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call PutKeyValue with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// var data = new {
        ///     key = "<key>",
        ///     label = "<label>",
        ///     content_type = "<content_type>",
        ///     value = "<value>",
        ///     last_modified = "2022-05-10T14:57:31.2311892-04:00",
        ///     tags = new {
        ///         key = "<String>",
        ///     },
        ///     locked = true,
        ///     etag = "<etag>",
        /// };
        /// 
        /// Response response = client.PutKeyValue("<key>", "<label>", "<apiVersion>", RequestContent.Create(data), "<syncToken>", "<accept>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response PutKeyValue(string key, string label, string apiVersion, RequestContent content, string syncToken = null, string accept = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("Client.PutKeyValue");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePutKeyValueRequest(key, label, apiVersion, content, syncToken, accept, matchConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a key-value. </summary>
        /// <param name="key"> The key of the key-value to delete. </param>
        /// <param name="label"> The label of the key-value to delete. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="ifMatch"> Used to perform an operation only if the targeted resource&apos;s etag matches the value provided. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        public virtual async Task<Response<global::.KeyValue>> DeleteKeyValueValueAsync(string key, string label, string apiVersion, string syncToken = null, string accept = null, string ifMatch = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.DeleteKeyValueValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await DeleteKeyValueAsync(key, label, apiVersion, syncToken, accept, ifMatch, context).ConfigureAwait(false);
                return Response.FromValue(global::.KeyValue.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a key-value. </summary>
        /// <param name="key"> The key of the key-value to delete. </param>
        /// <param name="label"> The label of the key-value to delete. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="ifMatch"> Used to perform an operation only if the targeted resource&apos;s etag matches the value provided. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        public virtual Response<global::.KeyValue> DeleteKeyValueValue(string key, string label, string apiVersion, string syncToken = null, string accept = null, string ifMatch = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.DeleteKeyValueValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = DeleteKeyValue(key, label, apiVersion, syncToken, accept, ifMatch, context);
                return Response.FromValue(global::.KeyValue.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a key-value. </summary>
        /// <param name="key"> The key of the key-value to delete. </param>
        /// <param name="label"> The label of the key-value to delete. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="ifMatch"> Used to perform an operation only if the targeted resource&apos;s etag matches the value provided. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteKeyValueAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.DeleteKeyValueAsync("<key>", "<label>", "<apiVersion>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call DeleteKeyValueAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.DeleteKeyValueAsync("<key>", "<label>", "<apiVersion>", "<syncToken>", "<accept>", null);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteKeyValueAsync(string key, string label, string apiVersion, string syncToken = null, string accept = null, ETag? ifMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.DeleteKeyValue");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteKeyValueRequest(key, label, apiVersion, syncToken, accept, ifMatch, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a key-value. </summary>
        /// <param name="key"> The key of the key-value to delete. </param>
        /// <param name="label"> The label of the key-value to delete. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="ifMatch"> Used to perform an operation only if the targeted resource&apos;s etag matches the value provided. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteKeyValue with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.DeleteKeyValue("<key>", "<label>", "<apiVersion>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call DeleteKeyValue with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.DeleteKeyValue("<key>", "<label>", "<apiVersion>", "<syncToken>", "<accept>", null);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteKeyValue(string key, string label, string apiVersion, string syncToken = null, string accept = null, ETag? ifMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.DeleteKeyValue");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteKeyValueRequest(key, label, apiVersion, syncToken, accept, ifMatch, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> The key of the key-value to retrieve. </param>
        /// <param name="label"> The label of the key-value to retrieve. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual async Task<Response> CheckKeyValueValueAsync(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Head7ItemsItem> select, string syncToken = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValueValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await CheckKeyValueAsync(key, label, apiVersion, acceptDatetime, select, syncToken, matchConditions, context).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> The key of the key-value to retrieve. </param>
        /// <param name="label"> The label of the key-value to retrieve. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual Response CheckKeyValueValue(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Head7ItemsItem> select, string syncToken = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValueValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = CheckKeyValue(key, label, apiVersion, acceptDatetime, select, syncToken, matchConditions, context);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> The key of the key-value to retrieve. </param>
        /// <param name="label"> The label of the key-value to retrieve. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckKeyValueAsync with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckKeyValueAsync("<key>", "<label>", "<apiVersion>", "<acceptDatetime>", new Head7ItemsItem[]{null});
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckKeyValueAsync with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckKeyValueAsync("<key>", "<label>", "<apiVersion>", "<acceptDatetime>", new Head7ItemsItem[]{null}, "<syncToken>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> CheckKeyValueAsync(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Head7ItemsItem> select, string syncToken = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValue");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckKeyValueRequest(key, label, apiVersion, acceptDatetime, select, syncToken, matchConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> The key of the key-value to retrieve. </param>
        /// <param name="label"> The label of the key-value to retrieve. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckKeyValue with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckKeyValue("<key>", "<label>", "<apiVersion>", "<acceptDatetime>", new Head7ItemsItem[]{null});
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckKeyValue with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckKeyValue("<key>", "<label>", "<apiVersion>", "<acceptDatetime>", new Head7ItemsItem[]{null}, "<syncToken>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response CheckKeyValue(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Head7ItemsItem> select, string syncToken = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckKeyValue");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckKeyValueRequest(key, label, apiVersion, acceptDatetime, select, syncToken, matchConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of labels. </summary>
        /// <param name="name"> A filter for the name of the returned labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual async Task<Response<global::.LabelListResult>> GetLabelValuesAsync(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Get5ItemsItem> select, string syncToken = null, string accept = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetLabelValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetLabelsAsync(name, apiVersion, after, acceptDatetime, select, syncToken, accept, context).ConfigureAwait(false);
                return Response.FromValue(global::.LabelListResult.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of labels. </summary>
        /// <param name="name"> A filter for the name of the returned labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual Response<global::.LabelListResult> GetLabelValues(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Get5ItemsItem> select, string syncToken = null, string accept = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetLabelValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetLabels(name, apiVersion, after, acceptDatetime, select, syncToken, accept, context);
                return Response.FromValue(global::.LabelListResult.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of labels. </summary>
        /// <param name="name"> A filter for the name of the returned labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLabelsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetLabelsAsync("<name>", "<apiVersion>", "<after>", "<acceptDatetime>", new Get5ItemsItem[]{null});
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// This sample shows how to call GetLabelsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetLabelsAsync("<name>", "<apiVersion>", "<after>", "<acceptDatetime>", new Get5ItemsItem[]{null}, "<syncToken>", "<accept>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LabelListResult</c>:
        /// <code>{
        ///   items: [
        ///     {
        ///       name: string, # Required.
        ///     }
        ///   ], # Required.
        ///   @nextLink: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLabelsAsync(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Get5ItemsItem> select, string syncToken = null, string accept = null, RequestContext context = null)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetLabels");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLabelsRequest(name, apiVersion, after, acceptDatetime, select, syncToken, accept, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of labels. </summary>
        /// <param name="name"> A filter for the name of the returned labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLabels with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetLabels("<name>", "<apiVersion>", "<after>", "<acceptDatetime>", new Get5ItemsItem[]{null});
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// This sample shows how to call GetLabels with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetLabels("<name>", "<apiVersion>", "<after>", "<acceptDatetime>", new Get5ItemsItem[]{null}, "<syncToken>", "<accept>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LabelListResult</c>:
        /// <code>{
        ///   items: [
        ///     {
        ///       name: string, # Required.
        ///     }
        ///   ], # Required.
        ///   @nextLink: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLabels(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Get5ItemsItem> select, string syncToken = null, string accept = null, RequestContext context = null)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetLabels");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLabelsRequest(name, apiVersion, after, acceptDatetime, select, syncToken, accept, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="name"> A filter for the name of the returned labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual async Task<Response> CheckLabelValuesAsync(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head5ItemsItem> select, string syncToken = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckLabelValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await CheckLabelsAsync(name, apiVersion, after, acceptDatetime, select, syncToken, context).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="name"> A filter for the name of the returned labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual Response CheckLabelValues(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head5ItemsItem> select, string syncToken = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckLabelValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = CheckLabels(name, apiVersion, after, acceptDatetime, select, syncToken, context);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="name"> A filter for the name of the returned labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckLabelsAsync with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckLabelsAsync("<name>", "<apiVersion>", "<after>", "<acceptDatetime>", new Head5ItemsItem[]{null});
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckLabelsAsync with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckLabelsAsync("<name>", "<apiVersion>", "<after>", "<acceptDatetime>", new Head5ItemsItem[]{null}, "<syncToken>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> CheckLabelsAsync(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head5ItemsItem> select, string syncToken = null, RequestContext context = null)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckLabels");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckLabelsRequest(name, apiVersion, after, acceptDatetime, select, syncToken, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="name"> A filter for the name of the returned labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckLabels with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckLabels("<name>", "<apiVersion>", "<after>", "<acceptDatetime>", new Head5ItemsItem[]{null});
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckLabels with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckLabels("<name>", "<apiVersion>", "<after>", "<acceptDatetime>", new Head5ItemsItem[]{null}, "<syncToken>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response CheckLabels(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head5ItemsItem> select, string syncToken = null, RequestContext context = null)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckLabels");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckLabelsRequest(name, apiVersion, after, acceptDatetime, select, syncToken, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Locks a key-value. </summary>
        /// <param name="key"> The key of the key-value to lock. </param>
        /// <param name="label"> The label, if any, of the key-value to lock. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        public virtual async Task<Response<global::.KeyValue>> PutLockValueAsync(string key, string label, string apiVersion, string syncToken = null, string accept = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.PutLockValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await PutLockAsync(key, label, apiVersion, syncToken, accept, matchConditions, context).ConfigureAwait(false);
                return Response.FromValue(global::.KeyValue.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Locks a key-value. </summary>
        /// <param name="key"> The key of the key-value to lock. </param>
        /// <param name="label"> The label, if any, of the key-value to lock. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        public virtual Response<global::.KeyValue> PutLockValue(string key, string label, string apiVersion, string syncToken = null, string accept = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.PutLockValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = PutLock(key, label, apiVersion, syncToken, accept, matchConditions, context);
                return Response.FromValue(global::.KeyValue.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Locks a key-value. </summary>
        /// <param name="key"> The key of the key-value to lock. </param>
        /// <param name="label"> The label, if any, of the key-value to lock. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call PutLockAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.PutLockAsync("<key>", "<label>", "<apiVersion>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call PutLockAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.PutLockAsync("<key>", "<label>", "<apiVersion>", "<syncToken>", "<accept>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> PutLockAsync(string key, string label, string apiVersion, string syncToken = null, string accept = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.PutLock");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePutLockRequest(key, label, apiVersion, syncToken, accept, matchConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Locks a key-value. </summary>
        /// <param name="key"> The key of the key-value to lock. </param>
        /// <param name="label"> The label, if any, of the key-value to lock. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call PutLock with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.PutLock("<key>", "<label>", "<apiVersion>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call PutLock with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.PutLock("<key>", "<label>", "<apiVersion>", "<syncToken>", "<accept>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response PutLock(string key, string label, string apiVersion, string syncToken = null, string accept = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.PutLock");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePutLockRequest(key, label, apiVersion, syncToken, accept, matchConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Unlocks a key-value. </summary>
        /// <param name="key"> The key of the key-value to unlock. </param>
        /// <param name="label"> The label, if any, of the key-value to unlock. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        public virtual async Task<Response<global::.KeyValue>> DeleteLockValueAsync(string key, string label, string apiVersion, string syncToken = null, string accept = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.DeleteLockValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await DeleteLockAsync(key, label, apiVersion, syncToken, accept, matchConditions, context).ConfigureAwait(false);
                return Response.FromValue(global::.KeyValue.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Unlocks a key-value. </summary>
        /// <param name="key"> The key of the key-value to unlock. </param>
        /// <param name="label"> The label, if any, of the key-value to unlock. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        public virtual Response<global::.KeyValue> DeleteLockValue(string key, string label, string apiVersion, string syncToken = null, string accept = null, MatchConditions matchConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.DeleteLockValue");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = DeleteLock(key, label, apiVersion, syncToken, accept, matchConditions, context);
                return Response.FromValue(global::.KeyValue.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Unlocks a key-value. </summary>
        /// <param name="key"> The key of the key-value to unlock. </param>
        /// <param name="label"> The label, if any, of the key-value to unlock. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteLockAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.DeleteLockAsync("<key>", "<label>", "<apiVersion>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call DeleteLockAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.DeleteLockAsync("<key>", "<label>", "<apiVersion>", "<syncToken>", "<accept>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteLockAsync(string key, string label, string apiVersion, string syncToken = null, string accept = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.DeleteLock");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLockRequest(key, label, apiVersion, syncToken, accept, matchConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Unlocks a key-value. </summary>
        /// <param name="key"> The key of the key-value to unlock. </param>
        /// <param name="label"> The label, if any, of the key-value to unlock. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/> or <paramref name="apiVersion"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call DeleteLock with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.DeleteLock("<key>", "<label>", "<apiVersion>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// This sample shows how to call DeleteLock with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.DeleteLock("<key>", "<label>", "<apiVersion>", "<syncToken>", "<accept>", new MatchConditions { IfMatch = "<YOUR_ETAG>" });
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValue</c>:
        /// <code>{
        ///   key: string, # Required.
        ///   label: string, # Required.
        ///   content_type: string, # Required.
        ///   value: string, # Required.
        ///   last_modified: string (date &amp; time), # Required.
        ///   tags: Dictionary&lt;string, string&gt;, # Required.
        ///   locked: boolean, # Required.
        ///   etag: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteLock(string key, string label, string apiVersion, string syncToken = null, string accept = null, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));

            using var scope = ClientDiagnostics.CreateScope("Client.DeleteLock");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLockRequest(key, label, apiVersion, syncToken, accept, matchConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of key-value revisions. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual async Task<Response<global::.KeyValueListResult>> GetRevisionValuesAsync(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Paths18s2vl1RevisionsGetParameters6SchemaItems> select, string syncToken = null, string accept = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetRevisionValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await GetRevisionsAsync(key, label, apiVersion, after, acceptDatetime, select, syncToken, accept, context).ConfigureAwait(false);
                return Response.FromValue(global::.KeyValueListResult.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of key-value revisions. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual Response<global::.KeyValueListResult> GetRevisionValues(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Paths18s2vl1RevisionsGetParameters6SchemaItems> select, string syncToken = null, string accept = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetRevisionValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = GetRevisions(key, label, apiVersion, after, acceptDatetime, select, syncToken, accept, context);
                return Response.FromValue(global::.KeyValueListResult.FromResponse(response), response);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of key-value revisions. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetRevisionsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetRevisionsAsync("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new Paths18s2vl1RevisionsGetParameters6SchemaItems[]{null});
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("etag").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// This sample shows how to call GetRevisionsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.GetRevisionsAsync("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new Paths18s2vl1RevisionsGetParameters6SchemaItems[]{null}, "<syncToken>", "<accept>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("etag").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValueListResult</c>:
        /// <code>{
        ///   items: [
        ///     {
        ///       key: string, # Required.
        ///       label: string, # Required.
        ///       content_type: string, # Required.
        ///       value: string, # Required.
        ///       last_modified: string (date &amp; time), # Required.
        ///       tags: Dictionary&lt;string, string&gt;, # Required.
        ///       locked: boolean, # Required.
        ///       etag: string, # Required.
        ///     }
        ///   ], # Required.
        ///   @nextLink: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetRevisionsAsync(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Paths18s2vl1RevisionsGetParameters6SchemaItems> select, string syncToken = null, string accept = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetRevisions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRevisionsRequest(key, label, apiVersion, after, acceptDatetime, select, syncToken, accept, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of key-value revisions. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="accept"> Accept header. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetRevisions with required parameters and parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetRevisions("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new Paths18s2vl1RevisionsGetParameters6SchemaItems[]{null});
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("etag").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// This sample shows how to call GetRevisions with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.GetRevisions("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new Paths18s2vl1RevisionsGetParameters6SchemaItems[]{null}, "<syncToken>", "<accept>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("key").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("label").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("content_type").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("value").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("last_modified").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("tags").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("locked").ToString());
        /// Console.WriteLine(result.GetProperty("items")[0].GetProperty("etag").ToString());
        /// Console.WriteLine(result.GetProperty("@nextLink").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>KeyValueListResult</c>:
        /// <code>{
        ///   items: [
        ///     {
        ///       key: string, # Required.
        ///       label: string, # Required.
        ///       content_type: string, # Required.
        ///       value: string, # Required.
        ///       last_modified: string (date &amp; time), # Required.
        ///       tags: Dictionary&lt;string, string&gt;, # Required.
        ///       locked: boolean, # Required.
        ///       etag: string, # Required.
        ///     }
        ///   ], # Required.
        ///   @nextLink: string, # Required.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetRevisions(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Paths18s2vl1RevisionsGetParameters6SchemaItems> select, string syncToken = null, string accept = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.GetRevisions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRevisionsRequest(key, label, apiVersion, after, acceptDatetime, select, syncToken, accept, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual async Task<Response> CheckRevisionValuesAsync(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.PathsEaaa80RevisionsHeadParameters6SchemaItems> select, string syncToken = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckRevisionValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = await CheckRevisionsAsync(key, label, apiVersion, after, acceptDatetime, select, syncToken, context).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        public virtual Response CheckRevisionValues(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.PathsEaaa80RevisionsHeadParameters6SchemaItems> select, string syncToken = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckRevisionValues");
            scope.Start();
            try
            {
                RequestContext context = FromCancellationToken(cancellationToken);
                Response response = CheckRevisions(key, label, apiVersion, after, acceptDatetime, select, syncToken, context);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckRevisionsAsync with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckRevisionsAsync("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new PathsEaaa80RevisionsHeadParameters6SchemaItems[]{null});
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckRevisionsAsync with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = await client.CheckRevisionsAsync("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new PathsEaaa80RevisionsHeadParameters6SchemaItems[]{null}, "<syncToken>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> CheckRevisionsAsync(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.PathsEaaa80RevisionsHeadParameters6SchemaItems> select, string syncToken = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckRevisions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckRevisionsRequest(key, label, apiVersion, after, acceptDatetime, select, syncToken, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Requests the headers and status of the given resource. </summary>
        /// <param name="key"> A filter used to match keys. </param>
        /// <param name="label"> A filter used to match labels. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <param name="after"> Instructs the server to return elements that appear after the element referred to by the specified token. </param>
        /// <param name="acceptDatetime"> Requests the server to respond with the state of the resource at the specified time. </param>
        /// <param name="select"> Used to select what fields are present in the returned resource(s). </param>
        /// <param name="syncToken"> Used to guarantee real-time consistency between requests. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/>, <paramref name="label"/>, <paramref name="apiVersion"/>, <paramref name="after"/>, <paramref name="acceptDatetime"/> or <paramref name="select"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call CheckRevisions with required parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckRevisions("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new PathsEaaa80RevisionsHeadParameters6SchemaItems[]{null});
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// This sample shows how to call CheckRevisions with all parameters.
        /// <code><![CDATA[
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new Client(endpoint);
        /// 
        /// Response response = client.CheckRevisions("<key>", "<label>", "<apiVersion>", "<after>", "<acceptDatetime>", new PathsEaaa80RevisionsHeadParameters6SchemaItems[]{null}, "<syncToken>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response CheckRevisions(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.PathsEaaa80RevisionsHeadParameters6SchemaItems> select, string syncToken = null, RequestContext context = null)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(label, nameof(label));
            Argument.AssertNotNull(apiVersion, nameof(apiVersion));
            Argument.AssertNotNull(after, nameof(after));
            Argument.AssertNotNull(acceptDatetime, nameof(acceptDatetime));
            Argument.AssertNotNull(select, nameof(select));

            using var scope = ClientDiagnostics.CreateScope("Client.CheckRevisions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCheckRevisionsRequest(key, label, apiVersion, after, acceptDatetime, select, syncToken, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetKeysRequest(string name, string apiVersion, string after, string syncToken, string acceptDatetime, string accept, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/keys", false);
            uri.AppendQuery("name", name, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("After", after, false);
            request.Uri = uri;
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (acceptDatetime != null)
            {
                request.Headers.Add("accept-datetime", acceptDatetime);
            }
            if (accept != null)
            {
                request.Headers.Add("accept", accept);
            }
            return message;
        }

        internal HttpMessage CreateCheckKeysRequest(string name, string apiVersion, string after, string syncToken, string acceptDatetime, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/keys", false);
            uri.AppendQuery("name", name, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("After", after, false);
            request.Uri = uri;
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (acceptDatetime != null)
            {
                request.Headers.Add("accept-datetime", acceptDatetime);
            }
            return message;
        }

        internal HttpMessage CreateGetKeyValuesRequest(string key, string label, string apiVersion, string after, IEnumerable<global::.Get6ItemsItem> select, string syncToken, string acceptDatetime, string accept, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/kv", false);
            uri.AppendQuery("key", key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("After", after, false);
            uri.AppendQuery("$Select", select, false);
            request.Uri = uri;
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (acceptDatetime != null)
            {
                request.Headers.Add("accept-datetime", acceptDatetime);
            }
            if (accept != null)
            {
                request.Headers.Add("accept", accept);
            }
            return message;
        }

        internal HttpMessage CreateCheckKeyValuesRequest(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head6ItemsItem> select, string syncToken, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/kv", false);
            uri.AppendQuery("key", key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("After", after, false);
            uri.AppendQuery("$Select", select, false);
            request.Uri = uri;
            request.Headers.Add("accept-datetime", acceptDatetime);
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            return message;
        }

        internal HttpMessage CreateGetKeyValueRequest(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Get7ItemsItem> select, string syncToken, string accept, MatchConditions matchConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/kv/", false);
            uri.AppendPath(key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("$Select", select, false);
            request.Uri = uri;
            request.Headers.Add("accept-datetime", acceptDatetime);
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (accept != null)
            {
                request.Headers.Add("accept", accept);
            }
            if (matchConditions != null)
            {
                request.Headers.Add(matchConditions);
            }
            return message;
        }

        internal HttpMessage CreatePutKeyValueRequest(string key, string label, string apiVersion, RequestContent content, string syncToken, string accept, MatchConditions matchConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/kv/", false);
            uri.AppendPath(key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            request.Uri = uri;
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (accept != null)
            {
                request.Headers.Add("accept", accept);
            }
            if (matchConditions != null)
            {
                request.Headers.Add(matchConditions);
            }
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteKeyValueRequest(string key, string label, string apiVersion, string syncToken, string accept, ETag? ifMatch, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200204);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/kv/", false);
            uri.AppendPath(key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            request.Uri = uri;
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (accept != null)
            {
                request.Headers.Add("accept", accept);
            }
            if (ifMatch != null)
            {
                request.Headers.Add("if-match", ifMatch.Value);
            }
            return message;
        }

        internal HttpMessage CreateCheckKeyValueRequest(string key, string label, string apiVersion, string acceptDatetime, IEnumerable<global::.Head7ItemsItem> select, string syncToken, MatchConditions matchConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/kv/", false);
            uri.AppendPath(key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("$Select", select, false);
            request.Uri = uri;
            request.Headers.Add("accept-datetime", acceptDatetime);
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (matchConditions != null)
            {
                request.Headers.Add(matchConditions);
            }
            return message;
        }

        internal HttpMessage CreateGetLabelsRequest(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Get5ItemsItem> select, string syncToken, string accept, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/labels", false);
            uri.AppendQuery("name", name, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("After", after, false);
            uri.AppendQuery("$Select", select, false);
            request.Uri = uri;
            request.Headers.Add("accept-datetime", acceptDatetime);
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (accept != null)
            {
                request.Headers.Add("accept", accept);
            }
            return message;
        }

        internal HttpMessage CreateCheckLabelsRequest(string name, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Head5ItemsItem> select, string syncToken, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/labels", false);
            uri.AppendQuery("name", name, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("After", after, false);
            uri.AppendQuery("$Select", select, false);
            request.Uri = uri;
            request.Headers.Add("accept-datetime", acceptDatetime);
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            return message;
        }

        internal HttpMessage CreatePutLockRequest(string key, string label, string apiVersion, string syncToken, string accept, MatchConditions matchConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/locks/", false);
            uri.AppendPath(key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            request.Uri = uri;
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (accept != null)
            {
                request.Headers.Add("accept", accept);
            }
            if (matchConditions != null)
            {
                request.Headers.Add(matchConditions);
            }
            return message;
        }

        internal HttpMessage CreateDeleteLockRequest(string key, string label, string apiVersion, string syncToken, string accept, MatchConditions matchConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/locks/", false);
            uri.AppendPath(key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            request.Uri = uri;
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (accept != null)
            {
                request.Headers.Add("accept", accept);
            }
            if (matchConditions != null)
            {
                request.Headers.Add(matchConditions);
            }
            return message;
        }

        internal HttpMessage CreateGetRevisionsRequest(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.Paths18s2vl1RevisionsGetParameters6SchemaItems> select, string syncToken, string accept, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/revisions", false);
            uri.AppendQuery("key", key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("After", after, false);
            uri.AppendQuery("$Select", select, false);
            request.Uri = uri;
            request.Headers.Add("accept-datetime", acceptDatetime);
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            if (accept != null)
            {
                request.Headers.Add("accept", accept);
            }
            return message;
        }

        internal HttpMessage CreateCheckRevisionsRequest(string key, string label, string apiVersion, string after, string acceptDatetime, IEnumerable<global::.PathsEaaa80RevisionsHeadParameters6SchemaItems> select, string syncToken, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            message.BufferResponse = false;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/", false);
            uri.AppendPath("/revisions", false);
            uri.AppendQuery("key", key, false);
            uri.AppendQuery("label", label, false);
            uri.AppendQuery("api-version", apiVersion, false);
            uri.AppendQuery("After", after, false);
            uri.AppendQuery("$Select", select, false);
            request.Uri = uri;
            request.Headers.Add("accept-datetime", acceptDatetime);
            if (syncToken != null)
            {
                request.Headers.Add("sync-token", syncToken);
            }
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier200204;
        private static ResponseClassifier ResponseClassifier200204 => _responseClassifier200204 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 204 });
    }
}
